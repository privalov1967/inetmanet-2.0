// Individual source, generated by MGI_Generator class object.
// Works finite time and then disappears.

#include <string>
#include <vector>
#include <math.h>
#include <omnetpp.h>

class Individual_MGI_Source : public cSimpleModule
{
  protected:
    simtime_t timeslot;      // time between packets
    int cellsize;            // cell size in bytes
    int pktsize;             // packet size in bytes
    simtime_t timeleft;      // time of working before disappirance

    cXMLElement *doc;        // file with source parameters

    cGate *dst;              // gate for packet direct sending 
    
    // Source speed parameters and functions       
    std::vector<double> dstS;
    int setPacketSize();
 
    // timeleft distribution parameters and functions
    std::vector<double> pA;   
    simtime_t setTimeLeft();     

    // The following redefined virtual function holds the algorithm.
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};


// The module class needs to be registered with OMNeT++
Define_Module(Individual_MGI_Source);


#define gDEBP(A,B) (A->getDocumentElementByPath(A,B))->getNodeValue()


void Individual_MGI_Source::initialize()
{
    // Initialize is called at the beginning of the simulation.
    

    doc=par("profile");

    // basic parameters initialization
    timeslot = atof(gDEBP(doc,"/TIMESLOT"));
    cellsize  = atoi(gDEBP(doc,"/CELLSIZE"));

    pktsize = setPacketSize();
    timeleft= setTimeLeft();  

    dst= getParentModule()->getSubmodule("collect")->gate("in");

    // Starting message scheduling
    cMessage *msg = new cMessage("next");
    scheduleAt( simTime(), msg);   
}


void Individual_MGI_Source::handleMessage(cMessage *msg)
{
    // The handleMessage() method is called whenever a message arrives
    // at the module.
    
    if ( timeleft>0) {  // generate new paket
       cPacket *pkt = new cPacket("packet");
       pkt->setByteLength(pktsize);
       sendDirect(pkt, dst);
       scheduleAt(simTime()+timeslot, msg);
       timeleft-=timeslot;
       }
    else {   // stop working and disappire
       delete msg;
       callFinish();
       deleteModule();
       }
}


int Individual_MGI_Source::setPacketSize()
{
   
    // reading data for source speed probability distribution
    cStringTokenizer tok(gDEBP(doc,"//SPEED-DISTRIBUTION"));  
    dstS = tok.asDoubleVector();
   
    // removing zero values from end of vector, if any
    int i;
    for(i=(int)dstS.size()-1; i>0 ;i--) if(dstS[i]!=0) break;
    dstS.resize(i+1);

    // random value of infospeed generation
    double s=0, x=uniform(0,1);
    for (i=0; i<(int)dstS.size(); i++) if( (s+=dstS[i])>x ) break;   
    return cellsize*i;
}

simtime_t Individual_MGI_Source::setTimeLeft()
{
    
    // preparing data for timeleft calculation
    cStringTokenizer tok(gDEBP(doc,"/ACF-SHAPE-PARAMETERS"));
    pA = tok.asDoubleVector();
    double alpha= pA[0];  
    double px   = pA[1];
    double py   = pA[2];
    double A    = pA[3];
    double imax = pA[4]+0.5;
    
    // timeleft random value generation
    int i;
    double s, x=uniform(0,1);
    for(s=py,i=2; x>=s && i<imax; i++) s+=A*pow(px+i,-alpha); 
    return timeslot*(i-1);
}
